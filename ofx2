#!/usr/bin/env bash
# Copyright (c) 2025 Erik Ben Heckman
# SPDX-License-Identifier: MIT
#
# ofx2  v0.7    <https://git.heckman.ca/ofx2>

# parse ofx files and...
# - print transactions as csv/tsv, to the terminal
#   or to a file, the name of which is generated from ofx data
# - rename the ofx file based on its data
# - print the ofx data to the terminal in a custom format


# shellcheck disable=SC2016  # variables are often expanded elsewhere
set -Eeu #o pipefail

requirements=( ofx2xml jq xq )
hashing_requirement=mlr # required for using the -h hash option

usage(){ echo '
Usage: ofx2 [-h|--help|-H] <command> [OPTIONS] <ofx_file> [<ofx_file2> ...]

The -h and --help options will print this message and quit.
The -H option will print a list of properties available to formatting options.

Otherwise, <command> must be one of the following:

   csv    Print transactions as comma-separated values (see below for options)
   tsv    Print transactions as tab-separated values (see below for options)
   info   [-F <format>|-P <preset>]
          Print a auto-generated information string, identifying the account
	  and the date-range of transactions.
          Customize the format with -F or -P options. See below for details.
   json   Dump the OFX file as structured json
   xml    Dump the OFX as well-formed XML.
          This effect is no different than running `ofx2xml`.
	  This command will be inferred when the first argument is a file.
   rename [-F <format>]
          Rename the ofx file based on file information.
	  Customize the format with the -F option. See below for details.

The folowing options are available for the csv and tsv commands:

   -F <array>   specify CSV fields to include with jq-parsed array
   -r           rename the ofx file based on file information; if format is
                specified with -W, it will be used for the new name
   -R <format>  like -r, but use jq-parsed value to format new name
   -a           include a default header row
   -A <array>   inlcude headers as specified by jq-parsed array
   -b           print an additional "transaction" declaring the closing balance
   -B <array>   append additional "transaction" as specified by jq-parsed array
   -m           include an additional column with a hash of the other fields
   -M <mlrexp>  like -m, but generated by a specified mlr expression
   -N <format>  like -m, but also specify a custom header for the hash column
                can be used in conjunction with -M
   -w           write output to file with an auto-generated name
   -W <format>  write output to file, name specified by js-parsed value
   -o           write output to file, name is based on the ofx filename
   -f           force overwrite of existing files when writing to file

Option arguments

      <array>   jq-parsed array like `[.ACCTID, .DTPOSTED, "$"+.TRNAMT]`
                note that square brackets are mandatory.
      <format>  jq-parsed value like `.INTBUD+"-"+.ACCTID` or `"foo"`.
                note that literal strings must be quoted.
      <mlrexp>  passed to miller to generate the value of hash to be
                added as an additional field in each transaction.
                For example, `md5($1.$2)` will hash the concatenation
                of the first two fields.
      <preset>  One of the following:
'"$(
for i in $( printf '%s\n' "${!PRESET_FORMATS[@]}" | sort )
do printf "%15s%-9s%s\n%25s(identical to -F '%s')\n" \
    "" "$i" "${PRESET_DESCRIPTIONS[$i]}" "" "${PRESET_FORMATS[$i]}"
done
)"'
To see a list of available properties available to <format> and <array>
options, use `ofx2 -V`.
'
}

declare -A PRESET_DESCRIPTIONS PRESET_FORMATS
define_preset(){ PRESET_DESCRIPTIONS[$1]="$2"; PRESET_FORMATS[$1]="$3"; }
define_preset range 'date range of transactions' '.DSTART + " to " + .DEND'
define_preset bank 'name of financial institution' '.BNM'
define_preset bnk 'abbreivated name of financial institution' '.BNS'
define_preset baank 'full name of financial institution' '.BNL'
define_preset account 'account number, as it appears in OFX file' '.ACCTID'


# Add an object for each the financial institutions you use.
# They are indexed by their INTU.BID value.
# INTU.BID is a Inutuit Bank ID; the values for North-American institutions can be found here:
# https://ofx-prod-filist.intuit.com/qm2400/data/fidir.txt
jq_fidir='
{
  "00002": {"short": "TD",   "medium": "TD Canada Trust", "long": "Toronto Dominion Canada Trust" },
  "00004": {"short": "FK",   "medium": "FK Canada Fake",  "long": "Fakey Fake Financial Canada" },
  "00005": {"short": "CIBC", "medium": "CIBC",            "long": "Canadian Imperial Bank of Commerce" },
  "00015": {"short": "RBC",  "medium": "RBC RoyalBank",   "long": "Royal Bank of Canada" },
  "00024": {"short": "PC",   "medium": "PC Financial",    "long": "President'"'"'s Choice Financial" }
}
'

jq_description_delimiter='; '

# Noe on the NAMING CONVENTION for variables:
#   a leading jq_ indicates the string is a fragment of jq code.
#   a leading mlr_ indicates a fragment of mlr code.

# The variables that follow define the output format.

available_properties(){ echo "
These properties are for building fragments of jq code.
Remember that literal strings must be quotes.

These three properties are always available:

   .PATH       Path of the OFX file as specified on command line.
   .FILENAME   Name of the OFX file, without directory.
   .BASENAME   Name of the OFX file, without directory,
               and stripped of any .ofx extension.

The following properties are usually available from an OFX file,
they have the same name as the tags in the OFX file:

   .INTBID     Intuit's Bank ID, stored in the <INTU.BID> tag.
               This will be read from a <FID><ID> tag if there
	       is no <INTU.BID> tag present.
   .BANKID     A nine-digit number. According to the OFX spec, this
               should be a routing number, but don't count on that.
   .ACCTID     Account number. This may contain spaces and hyphens.
   .ACCTTYPE   Type of account; one of: Bank, Credit.
               (Other types will probably cause this script to fail.)
   .LEDGERBAL  The account balance at the end date of transactions.
   .AVAILBAL   The available balance at the end date of transactions.
   .CURDEF     The currency code of the account.

The following derived from .INTBID and a bank list in the script:

   .BNS        Short-form name of Bank
   .BNM        Short-form name of Bank
   .BNL        Long-form name of Bank

These are defived from the account number in .ACCTID

   .ACCTN      Account number with all non numbers removed
   .ACCTSFX    The last 4 digits of .ACCTN

The start and end dates of the transactions should be available from an
OFX file. The following properties are derived from the original
DTSTART and DTEND tags:

   .DSTART     Start date of included transactions as YYYY-MM-DD
   .DTSTART    Start date-time of included transactions without time zone or sub-seconds.
   .TZSTART    Time Zone of start date-time of included transactions.
   .DEND       End date of included transactions as YYYY-MM-DD
   .DTEND      End date-time of included transactions without time zone or sub-seconds.
   .TZEND      Tome sone of end date-time of included transactions.

These are date and time information for the ending balances of the account:

   .LEDGERD    The date of the account balance as YYYY-MM-DD
   .LEDGERDT   The date-time of the account balance without time zone or sub-seconds.
   .LEDGERTZ   The time zone of the account balance.
   .AVAILD     The date of the available balance as YYYY-MM-DD
   .AVAILDT    The date-time of the available balance without time zone or sub-seconds.
   .AVAILTZ    The time zone of the available balance.

In addition to the above properties, the following fields are usually available
for transactions:

   .FITID       Transaction ID, should be unique to each account of a financial institution.
   .TRNTYPE     Transaction type (CREDIT, DEBIT, ATM, etc.)
   .TRNAMT      Positive for credits, negative for debits, no dollar sign.
   .NAME        The first line of the description.
   .MEMO        The second line of the description.

A description property is derived from .NAME and .MEMO

   .DESC        If either NAME or MEMO is empty, DESC will be the same as the
                non-empty one. When NAME and MEMO are both non-empty, DESC is
                formed by joining them with the delimiter '$jq_description_delimiter'.

These are derived from the OFX's native DTPOSTED tag

   .DTPOSTED    original .DTPOSTED with sub-seconds and time zone removed.
   .DPOSTED     Date in YYYY-MM-DD format, derived from DTPOSTED.
   .TZPOSTED    Time Zone of DTPOSTED.

"
}

# the following default formats can be redefined with command-line options

# format used for naming output files
jq_filename_format='
	.BNS + "-" + .ACCTSFX + " transactions from " + .DSTART + " to " + .DEND
'

# format used for renaming ofx files, if blank will default to jq_filename_format
jq_rename_format=''

# format of info string
jq_info_format='
	.BNL + ", account " + .ACCTID + ", from " +
	.DSTART + " to " + .DEND + "."'

# these three jq arrays should correspond to the same output columns
# columns headers
jq_header_fields_array='
	[
		"ACCOUNT",
		"ID",
		"DATE POSTED",
		"DESCRIPTION",
		"AMOUNT",
		"CURRENCY"
	]
'
# the header for the optional clculated hash.
# note that strings must include surrounding quotes.
jq_hash_header='"HASH"'

# columns values
jq_txn_fields_array='
	[
		(.BNS + "-" + .ACCTSFX),
		.FITID,
		.DPOSTED,
		.DESC,
		.TRNAMT,
		.CURDEF
	]
'

# parsed by miller(mlr) to generate a hash value
mlr_hash_definition='md5($1 . $2)'

# column footer (used to indicate closing balance
# a hash column will always be "" in the footer
jq_balance_fields_array='
	[
		(.BNS + "-" + .ACCTSFX),
		"BALANCE",
		.LEDGERD,
		.LEDGERBAL,
		"",
		.CURDEF
	]
'

# default options, can be modified by command-line options
WRITE_TO_FILE=false
USE_OFX_BASENAME=false
FORCE_OVERWRITE=false
RENAME_OFX=false
ADD_HEADERS=false
ADD_BALANCE=false
ADD_HASH=false
TABLE_TYPE=
SUBCOMMAND=

# possible errors
#
declare -A ERROR_FORMAT
declare -Ai EXIT_CODE
define_error(){ EXIT_CODE[$2]="$1"; ERROR_FORMAT[$2]="$3"; }
# THIS SHOULDN'T HAPPEN--ALL ERRORS SHOULD BE SPECIFIED
define_error 2  UNSPECIFIED "Unspecified error, this should not happen."
# PROBLEMS WITH ENVIRONMENT
define_error 13 NO_REQ      "External command '%s' is required and not found."
define_error 14 NO_HASH_REQ "External command '%s' is requred for generating a hash, but can't be found."
# PROBLEM WITH XML
define_error 51 BAD_XML      "Failed to parse XML for %s."
# PROBLEMS WITH ARGUMENTS
define_error 61 NO_CMD      "No command specified."
define_error 62 BAD_CMD     "'%s' is not a valid command."
define_error 63 BAD_OPT     "There is no opeion -%s."
define_error 64 NO_OPTARG   "Option -%s requires an argument"
define_error 65 BAD_PRESET  "'%s' is not a valid preset."
define_error 66 BAD_JQ_FRAG "Can't parse jq fragment: %s"
define_error 67 BAD_JQ_ARRY "Can't parse jq fragment: %s\n       Perhaps you forgot to enclose an array with []?"
define_error 68 NO_FILE     "No file specified."
# PROBLEMS WITH FILE ACCESS
define_error 71 BAD_FILE    "File '%s' not found."
define_error 72 UNREADABLE  "File '%s' is unreadable."
# PROGRAMMING ERROR
define_error 99 INTERNAL    "Internal error on line %s. This is very bad."
define_error 98 UNEXPECTED  "Unexpected error. This is very bad.\n  Command:     %s\n  Line Number: %s\n  Function:    %s\n  Exit Code:   %s"

trap 'die UNEXPECTED "$BASH_COMMAND" "$LINENO" "${FUNCNAME[0]}" "$?"' ERR


# global variable of filename of ofx file currently being processed
declare ofx

# global variables with parsed ofx data
declare xml raw_json json

main(){
	local missing
	# shellcheck disable=SC2086  # we wnat $missing to split
	missing="$(missing_reqs "${requirements[@]}")" ||
		die NO_REQ $missing

	parse_args "$@" || shift $?

	! $ADD_HASH || 	missing="$(missing_reqs "$hashing_requirement")" ||
		die NO_HASH_REQ "$hashing_requirement"

	[[ $# -gt 0 ]] || die NO_FILE

	local -i failed=0
	for ofx in "$@"; do
		[[ -f "$ofx" ]] || die BAD_FILE "$ofx"
		[[ -r "$ofx" ]] || die UNREADABLE "$ofx"

		xml=$(ofx2xml "$ofx") || {
			warn "Failed to parse '$ofx. Skipping."
			((failed++)) || :
			continue
		}
		raw_json=$(xq -j <<<"$xml")
		json=$(normalize_json <<<"$raw_json")

		case "${SUBCOMMAND:-transactions}" in
		xml) echo "$xml";;
		json) echo "$json";;
		raw-json) echo "$raw_json";;
		transactions) transactions;;
		info) print_info "$jq_info_format";;
		no-op) :;;
		'') die NO_CMD;;
		*) die_hard
		esac
		if $RENAME_OFX
		then rename
		fi
	done
	if ((failed>0))
	then die BAD_XML "$failed of $# files"
	fi
}

parse_args(){
	set -e
	TABLE_TYPE="csv"
	case "${1:-}" in
	'')
		usage
		exit 1
		;;
	-h|--help)
		usage
		exit 0
		;;
	-H)
		available_properties
		exit 0
		;;
	tsv)
		TABLE_TYPE="tsv"
		;&
	csv|txns|transactions) shift
		SUBCOMMAND=transactions
		while getopts ':taA:bB:fF:mM:N:orR:wW:' opt
		do
			case "$opt" in

		# TABLE-FORMATTING OPTIONS
			t) TABLE_TYPE="tsv";;
			F) jq_txn_fields_array="$OPTARG";;

			a) ADD_HEADERS=true;;
			A) ADD_HEADERS=true; jq_header_fields_array="$OPTARG";;

			b) ADD_BALANCE=true;;
			B) ADD_BALANCE=true; jq_balance_fields_array="$OPTARG";;

			m) ADD_HASH=true;;
			M) ADD_HASH=true; mlr_hash_definition="$OPTARG";;
			N) ADD_HASH=true; jq_hash_header="$OPTARG";;

		# DESTINATION OPTIONS
			w) WRITE_TO_FILE=true;;
			W) WRITE_TO_FILE=true; jq_filename_format="$OPTARG";;
			o) WRITE_TO_FILE=true; USE_OFX_BASENAME=true;;

			f) FORCE_OVERWRITE=true;;

		# OFX-RENAMING OPTIONS
			r) RENAME_OFX=true;;
			R) RENAME_OFX=true; jq_rename_format="$OPTARG";;

			:) die NO_OPTARG "$OPTARG";;
			\?) die BAD_OPT "$OPTARG";;
			*) die_hard
			esac
		done
		;;

	info) shift
		SUBCOMMAND=info
		while getopts ":F:P:" opt
		do
			case "$opt" in

			F) jq_info_format="$OPTARG";;
			P) jq_info_format="${PRESET_FORMATS[$OPTARG]:-}"
				[[ -n "$jq_info_format" ]] ||
				die BAD_PRESET "$OPTARG";;

			:) die NO_OPTARG "$OPTARG";;
			\?) die BAD_OPT "$OPTARG";;
			*) die_hard

			esac
		done
		;;

	json) shift
		SUBCOMMAND=json
		;;

	xml) shift
		SUBCOMMAND=xml
		# -j this option is for debugging purposes
		while getopts ":j:" opt
		do
			case "$opt" in

			j) SUBCOMMAND=raw_json;;

			:) die NO_OPTARG "$OPTARG";;
			\?) die BAD_OPT "$OPTARG";;
			*) die_hard

			esac
		done
		;;

	rename) shift
		SUBCOMMAND=no-op
		RENAME_OFX=true
		while getopts ":R:F:" opt
		do
			case "$opt" in

			R|F) jq_rename_format=$OPTARG;;

			:) die NO_OPTARG "$OPTARG";;
			\?) die BAD_OPT "$OPTARG";;
			*) die_hard

			esac
		done
		;;

	*)
		if [[ -f "$1" ]]
		then
			SUBCOMMAND=xml
			return 0
		else
			die BAD_CMD "$1"
		fi
esac
	return $OPTIND
}

print_info(){
	jq -r "$1" <<<"$json" || die BAD_JQ_FRAG "$1"
}

print_rows(){
	jq -r "$1 | @${TABLE_TYPE}" <<<"$json" || die BAD_JQ_ARRY "$1"
}

transactions()( # this needs to be a subshell because we're redirecting stdout
	if $WRITE_TO_FILE
	then
		local output_filename
		if output_filename="$(generate_filename "$TABLE_TYPE")" &&
			check_filename "$output_filename"
		then
			info "Writing transactions from '$ofx' to '$output_filename'"
			exec > "$output_filename"
		else
			return 1
		fi
	fi
	{
		local jq_header_fields jq_txn_fields jq_footer_fields

		jq_header_fields="${jq_header_fields_array}"
		jq_txn_fields=".TRANSACTIONS | map( . | $jq_txn_fields_array ) | .[]"
		jq_footer_fields="${jq_balance_fields_array}"

		if $ADD_HASH
		then
			if $ADD_HEADERS
			then print_rows "${jq_header_fields%]*},${jq_hash_header}]"
			fi
			print_rows "$jq_txn_fields" |
				mlr -N --quote-all "-$TABLE_TYPE" \
					put "\$hash=$mlr_hash_definition"
			if $ADD_BALANCE
			then print_rows "${jq_footer_fields%]*},\"\"]"
			fi
		else
			if $ADD_HEADERS
			then print_rows "$jq_header_fields"
			fi
			print_rows "$jq_txn_fields"

			if $ADD_BALANCE
			then print_rows "$jq_footer_fields"
			fi
		fi
	}
)

generate_filename(){ local extension="$1"
	local new_basename
	if new_basename="$(
		if $USE_OFX_BASENAME
		then basename "-s.ofx" "$ofx"
		else jq -r "${jq_rename_format:-$jq_filename_format}" <<<"$json"
		fi
	)" && [[ -n "${new_basename}" ]]
	then echo "$new_basename.$extension"
	else warn "Unable to generate new filename for '$ofx'"; return 1
	fi
}

check_filename(){ local filename="$1"
	if [[ -d "$filename" ]]
	then
		warn "Directory '$filename' exists; skipping."
		return 1
	elif [[ -e "$filename" ]] && ! $FORCE_OVERWRITE
	then
		warn "File '$filename' exists; skipping."
		return 1
	elif [[ -e "$filename" ]] && $FORCE_OVERWRITE
	then
		info "File '$filename' exists; overwriting."
	fi
}

rename(){
	local new_filename dir
	dir="$(dirname "$ofx")"
	if new_filename="$(generate_filename ofx)" &&
		check_filename "$dir/$new_filename"
	then
		info "Renaming '$ofx' to '$dir/$new_filename'"
		mv "$ofx" "$dir/$new_filename"
	else
		return 1
	fi
}

missing_reqs(){
	local required
	local -i missing=0
	for required in "${@}"
	do
		if ! command -v "$required" >/dev/null
		then
			echo "$required"
			((missing++))
		fi
	done
	return $missing
}

check_requirements(){ # args are required commands
	local required
	local -i status=0
	for required in "${@}"
	do
		if ! command -v "$required" >/dev/null
		then
			warn "Missing required command: $required"
			status=1
		fi
	done
	return $status
}

info(){ local message="$1"; echo "$message" >&2; }
warn(){ local message="$1"; echo "$message" >&2; }

# shellcheck disable=SC2059 # format is variable so format is a variable
die(){ local error="$1"; shift
	printf "ERROR: ${ERROR_FORMAT[$error]:-%s}\n" "${@:-$error}" >&2
	exit ${EXIT_CODE[$error]:-${1:-${EXIT_CODE[UNSPECIFIED]}}}
}

die_hard(){
	die INTERNAL "$( caller | sed 's/ / of /')"
}

normalize_json(){
	jq  -r \
		--argjson file '{
			"PATH": "'"$ofx"'",
			"FILENAME": "'"$(basename "$ofx")"'",
			"BASENAME": "'"$(basename "-s.ofx" "$ofx")"'"
			}' \
		--argjson fidir "$jq_fidir" \
		--arg desc_delim "$jq_description_delimiter" '

def add_missing_cents:
	gsub("^(?<a>-?\\d+)$";"\(.a).00") | gsub("^(?<a>-?\\d+\\.\\d)$";"\(.a)0")
;
def to_date_time($digits):
	($digits[0:4]+"-"+$digits[4:6]+"-"+digits[6:8]+"T"+digits[8:10]+":"+digits[10:12]+":"+digits[12:14])
;
def to_date($digits):
	($digits[0:4]+"-"+$digits[4:6]+"-"+digits[6:8])
;
def to_time_zone($digits):
	$digits | gsub("^[0-9.]*\\[";"") | gsub(":[A-Z]*\\]";"")
;
def add_derived_bank_names($s): $s | . + {
	BNS: $fidir[$s.INTBID].short,
	BNM: $fidir[$s.INTBID].medium,
	BNL: $fidir[$s.INTBID].long
};
def file_info: {
	BANKID: ((.BANKACCTFROM.BANKID // "")+(.CCACCTFROM.BANKID // "")),
	ACCTID: ((.BANKACCTFROM.ACCTID // "")+(.CCACCTFROM.ACCTID // "")),
	DTSTART: (.BANKTRANLIST.DTSTART // ""),
	DTEND: (.BANKTRANLIST.DTEND // ""),
	LEDGERBAL: (.LEDGERBAL.BALAMT // "" | add_missing_cents),
	LEDGERDT: (to_date_time(.LEDGERBAL.DTASOF // "" ) ),
	LEDGERD: (to_date(.LEDGERBAL.DTASOF // "" ) ),
	LEDGERTZ: (to_time_zone(.LEDGERBAL.DTASOF // "" ) ),
	AVAILBAL: (.AVAILBAL.BALAMT // "" | add_missing_cents),
	AVAILDT: (to_date_time(.AVAILBAL.DTASOF // "" ) ),
	AVAILD: (to_date(.AVAILBAL.DTASOF // "" ) ),
	AVAILTZ: (to_time_zone(.AVAILBAL.DTASOF // "" ) ),
	CURDEF: (.CURDEF // "")
};
def add_derived_file_info($s): $s | . + {
	ACCTN: ($s.ACCTID | gsub("[^A-Za-z0-9]"; "")),
	ACCTSFX: ($s.ACCTID | gsub("[^A-Za-z0-9]"; "") | .[-4:]),
	DSTART: to_date($s.DTSTART),
	TZSTART: to_time_zone($s.DTSTART),
	DTSTART: to_date_time($s.DTSTART),
	DEND: to_date($s.DTEND),
	TZEND: to_time_zone($s.DTEND),
	DTEND: to_date_time($s.DTEND)
};
def derived_transaction_fields: {
	DPOSTED: to_date(.DTPOSTED),
	TZPOSTED: to_time_zone(.DTPOSTED),
	DTPOSTED: to_date_time(.DTPOSTED),
	DESC: (
		if ((.NAME//"") != "" and (.MEMO//"") != "")
		then (.NAME//"") + $desc_delim + (.MEMO//"")
		else (.NAME//"") + (.MEMO//"")
		end
	),
	# in transaction amounts, add zeros for cents if missing
	TRNAMT: (
		.TRNAMT | add_missing_cents
	)
};
def get_intbid: { INTBID: (.SIGNONMSGSRSV1.SONRS.FI.FID // "") };
def wrap: if type == "array" then . else [.] end;
def first: if type == "array" then .[0] else . end;

.OFX
| $file + ( add_derived_bank_names(get_intbid) ) as $props
|
if has("BANKMSGSRSV1") then
	( $props + { ACCTTYPE: "Bank" } ) as $props
	| .BANKMSGSRSV1.STMTTRNRS | first | .STMTRS
elif has("CREDITCARDMSGSRSV1") then
	( $props + { ACCTTYPE: "Credit" } ) as $props
	| .CREDITCARDMSGSRSV1.CCSTMTTRNRS | first | .CCSTMTRS
else
	error("Unknown OFX type")
end
| ( add_derived_file_info($props + file_info) ) as $props
| .BANKTRANLIST
| . += $props
| .TRANSACTIONS=(.STMTTRN | wrap | map( . + $props + derived_transaction_fields) )
| del(.STMTTRN)
	'
}

main "$@"
