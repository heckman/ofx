#!/usr/bin/env bash
# Copyright (c) 2025 Erik Ben Heckman
# SPDX-License-Identifier: MIT
#
# ofx-txns
# v0.6

# parse ofx files
# and write transactions to csv/tsv files


# shellcheck disable=SC2016  # variables are often expanded elsewhere
# set -x
set -eu #o pipefail

requirements=( ofx2xml jq xq )
hashing_requirement=mlr # required for using the -h hash option

usage(){ echo '
Usage: ofx-txns [options] <ofx_file> [<another_ofx_file> ...]

The folowing options are mutually exclusive:

               TABLE of TRANSACTIONS
   -c          print transactions to stdout as CSV (default)
   -C <array>  specify CSV fields to include with jq-parsed array
   -t          print transactions to stdout as TSV
   -T <array>  specify TSV fields to include with jq-parsed array

               INFORMATION
   -i          print information about the ofx file
   -I <format> print information in the specified jq-parsed format
   -p <preset> print information in one of the preset formats

               DATA DUMP
   -j          print the interpreted ofx data as JSON
   -J          print a naiive conversion of the ofx file as JSON
   -x          print the ofx file as well-formatted XML

               OTHER
   -h          display this help and exit
   -s          produce no(ish) output (silent mode)
               errors may produce output

One of these options may also be specified:

   -r          rename the ofx file based on file information
   -R <format> use jq-parsed value to rename original ofx

The -c, -C, -t, -T options produce tabular output of the transactions,
and can take these additional options:

   -a           include a default header row
   -A <array>   inlcude headers as specified by jq-parsed array
   -b           print an additional "transaction" declaring the closing balance
   -B <array>   append additional "transaction" as specified by jq-parsed array
   -m           include an additional column with a hash of the other fields
   -M <mlrexp>  like -m, but generated by a specified mlr expression
   -N <format>  like -m, but also specify a custom header for the hash column
                can be used in conjunction with -M
   -w           write output to file with an auto-generated name
   -W <format>  write output to file, name specified by js-parsed value
   -o           write output to file, name is based on the ofx filename
   -f           force overwrite of existing files when writing to file

Option arguments

   <array>   jq-parsed array like `[.ACCTID, .DTPOSTED, "$"+.TRNAMT]`
             note that square brackets are mandatory.
   <format>  jq-parsed value like `.INTBUD+"-"+.ACCTID` or `"foo"`.
             note that literal strings must be quoted.
   <mlrexp>  passed to miller to generate the value of hash to be added as an
             additional field in each transaction. For example, `md5($1.$2)`
             will hash the concatenation of the first two fields.
   <preset>  One of the following:
             bank      print name of bank (same as `info -F ".BNM"`)
             bnk       print shorter name of bank (same as `info -F ".BNS"`)
             baank     print longer name of bank (same as `info -F ".BNL"`)
             account   print account number (same as `info -F ".ACCTID"`)
             range     print date-range of transactions

The source code of this script includes comments explaining the variables
available for use in the <array> and <format> arguments.
'
}


# Add an object for each the financial institutions you use.
# They are indexed by their INTU.BID value.
# INTU.BID is a Inutuit Bank ID; the values for North-American institutions can be found here:
# https://ofx-prod-filist.intuit.com/qm2400/data/fidir.txt
_fidir='
{
  "00002": {"short": "TD",   "medium": "TD Canada Trust", "long": "Toronto Dominion Canada Trust" },
  "00004": {"short": "FK",   "medium": "FK Canada Fake",  "long": "Fakey Fake Financial Canada" },
  "00005": {"short": "CIBC", "medium": "CIBC",            "long": "Canadian Imperial Bank of Commerce" },
  "00015": {"short": "RBC",  "medium": "RBC RoyalBank",   "long": "Royal Bank of Canada" },
  "00024": {"short": "PC",   "medium": "PC Financial",    "long": "President'"'"'s Choice Financial" }
}
'

# Noe on the NAMING CONVENTION for variables:
#   a leading _ indicates the string is a fragment of jq code.
#   a leading __ indicates a fragment of mlr code.


# The variables that follow define the output format.

# The following fields are usually available from an OFX file:
# (fields marked with and * are generated by this script, derived from other fields)
#
# .INTBID     Intuit's Bank ID, stored in the <INTU.BID> tag.
# .BNS      * Short-form name of Bank, derived from .INTBID and bank list defined below.
# .BNM      * Short-form name of Bank, derived from .INTBID and bank list defined below.
# .BNL      * Long-form name of Bank, derived from .INTBID and bank list defined below.
# .BANKID     A nine-digit number, supposed to be a routing number, but often not.
# .ACCTID     Account number as it appears in the OFX file.
# .ACCTN    * Account number with all non numbers removed, derived from ACCTID.
# .ACCTSFX  * The last 4 digits of the account number, derived from ACCTID.
# .ACCTTYPE   Type of account, one of: Bank, Credit.
# .DSTART   * Start date of included transactions as YYYY-MM-DD, derived from DTSTART.
# .DTSTART  * Start date of included transactions without time zone or sub-seconds.
# .TZSTART  * Tome sone of start date-time of included transactions.
# .DEND     * End date of included transactions as YYYY-MM-DD, derived from DTEND.
# .DTEND    * End date-time of included transactions without time zone or sub-seconds.
# .TZEND    * Tome sone of end date-time of included transactions.
# .LEDGERBAL  The account balance at the end date of transactions.
# .LEDGERD  * The date of the account balance as YYYY-MM-DD, derived from .LEDGERDT
# .LEDGERDT * The date-time of the account balance without time zone or sub-seconds.
# .LEDGERTZ * The time zone of the account balance.
# .AVAILBAL   The available balance at the end date of transactions.
# .AVAILD   * The date of the available balance as YYYY-MM-DD, derived from .AVAILDT
# .AVAILDT  * The date-time of the available balance without time zone or sub-seconds.
# .AVAILTZ  * The time zone of the available balance.
# .CURDEF     The currency code of the account.
#
# Additionally, the following fields are usually available for transactions:
#
# .FITID       Transaction ID, should be unique to each account of a financial institution.
# .DPOSTED   * Date in YYYY-MM-DD format, derived from DTPOSTED.
# .DTPOSTED  * original .DTPOSTED with sub-seconds and time zone removed.
# .TZPOSTED  * Time Zone of DTPOSTED.
# .TRNTYPE     Transaction type (CREDIT, DEBIT, ATM, etc.)
# .TRNAMT      Positive for credits, negative for debits, no dollar sign.
# .NAME        The first line of the description.
# .MEMO        The second line of the description.
# .DESC      * Description, derived from NAME and MEMO, which, when both are non-empty,
#              are joined by a delimiter defined below. (If either is empty then
#              they are joined without a delimiter.)
_description_deliminator='; '
# _description_deliminator='
# '

# format used for naming output files
_filename_format='
	.BNS + "-" + .ACCTSFX + " transactions from " + .DSTART + " to " + .DEND
'
# format used for renaming ofx files, if blank will default to _filename_format
_rename_format=''

# format of info string
_info_format='
	.BNL + ", account " + .ACCTID + ", from " +
	.DSTART + " to " + .DEND + "."'

# format of range string
_range_format='.DSTART + " to " + .DEND'


# these three jq arrays should correspond to the same output columns
# columns headers
_transaction_headers_array='
	[
		"ACCOUNT",
		"ID",
		"DATE POSTED",
		"DESCRIPTION",
		"AMOUNT",
		"CURRENCY"
	]
'
# the header for the optional clculated hash.
# note that strings must include surrounding quotes.
_hash_header='"HASH"'

# columns values
_transaction_fields_array='
	[
		(.BNS + "-" + .ACCTSFX),
		.FITID,
		.DPOSTED,
		.DESC,
		.TRNAMT,
		.CURDEF
	]
'
__hash_definition='md5($1 . $2)'
# column footer (used to indicate closing balance
_balance_fields_array='
	[
		(.BNS + "-" + .ACCTSFX),
		"BALANCE",
		.LEDGERD,
		.LEDGERBAL,
		"",
		.CURDEF
	]
'
# a hash column will always be "" in the footer


# default options, can be modified by command-line options
WRITE_TO_FILE=false
USE_OFX_BASENAME=false
FORCE_OVERWRITE=false
RENAME_OFX=false
HEADERS=false
BALANCE=false
HASH=false
TABLE_TYPE="csv"
CMD=

# error exit codes
declare -Air ERR=(
	[BAD_OPT]=2 # invalid command-line option
	[NO_ARG]=3  # command-line option missing required argument
	[NO_CMD]=4  # no command specified
	[BAD_CMD]=5 # invalid command specified
	[BAD_PRESET]=6 # invalid preset specified
	[PANIC]=8 # generic internal error; this should never happen
	[INTERNAL_ERROR]=9 # these should not happen
	[FILE_EXISTS]=12 # file already exists and not overwriting
	[BAD_FILE]=13 # file doesn't exist or is not readable
	[MISSING_REQUIREMENT]=14
)


# this is a global variable containing the path to the current OFX file
declare ofx

declare -Ar PRESETS=(
	[range]="$_range_format"
	[bank]='.BNM'
	[bnk]='.BNS'
	[baank]='.BNL'
	[account]='.ACCTID'
)

main(){
	check_requirements "${requirements[@]}" || die "Aborting." ${ERR[MISSING_REQUIREMENT]}
	parse_options "$@" || shift $?
	if $HASH
	then
		check_requirements "$hashing_requirement" ||
		die "Can't hash without it; aborting." ${ERR[MISSING_REQUIREMENT]}
	fi
	for ofx in "$@"; do
		[[ -f "$ofx" ]] || die "File not found: $ofx" ${ERR[BAD_FILE]}
		[[ -r "$ofx" ]] || die "Can't read file: $ofx" ${ERR[BAD_FILE]}

		xml=$(ofx2xml "$ofx")
		raw_json=$(xq -j <<<"$xml")
		json=$(normalize_json <<<"$raw_json")

		case "${CMD:-transactions}" in
		xml) echo "$xml";;
		json) echo "$json";;
		raw-json) echo "$raw_json";;
		transactions) transactions;;
		info) info "$_info_format" ;;
		no-op) :;;
		*) die "Unconfigured commmand: '$CMD'." ${ERR[INTERNAL_ERROR]};;
		esac

		if $RENAME_OFX
		then
			rename
		fi
	done
}

parse_options(){
	if [[ "${1:--help}" == '--help' ]]; then usage; exit 0; fi
	while getopts ":fhjJxsaA:bB:cC:iI:mM:N:oP:rR:tT:wW:" opt
	do
	case "$opt" in
	a) HEADERS=true;;
	A) HEADERS=true
		_transaction_headers_array="$OPTARG";;
	b) BALANCE=true;;
	B) BALANCE=true
		_balance_fields_array="$OPTARG";;
	c) set_command transactions
		TABLE_TYPE="csv";;
	C) set_command transactions
		TABLE_TYPE="csv"
		_transaction_fields_array="$OPTARG";;
	# d
	# e
	f) FORCE_OVERWRITE=true;;
	# g
	h) usage; exit 0;;
	i) set_command info;;
	I) set_command info
		_info_format="$OPTARG";;
	j) set_command json;;
	J) set_command raw-json;;
	# k
	# l
	m) HASH=true;;
	M) HASH=true
		__hash_definition="$OPTARG";;
	s) set_command no-op;;
	N) HASH=true
		_hash_header="$OPTARG";;
	# n
	o) WRITE_TO_FILE=true
		USE_OFX_BASENAME=true;;
	P) set_command info
		_info_format=PRESETS["${OPTARG:-}"]
		[[ -n "$_info_format" ]] ||
		die "Unconfigured preset: '$OPTARG'." ${ERR[BAD_PRESET]};;
	# q
	r) RENAME_OFX=true;;
	R) RENAME_OFX=true
		_rename_format="$OPTARG";;
	# s
	t) set_command transactions
		TABLE_TYPE="tsv";;
	T) set_command transactions
		TABLE_TYPE="tsv"
		_transaction_fields_array="$OPTARG";;
	# u
	# v) version; exit 0;;
	w) WRITE_TO_FILE=true;;
	W) WRITE_TO_FILE=true
		_filename_format="$OPTARG";;
	x) set_command xml;;
	# y
	# z
	:) die "Option -$OPTARG requires an argument" ${ERR[NO_ARG]};;
	\?) die "Invalid option: -$OPTARG" ${ERR[BAD_OPT]};;
	*) die_hard "Unhandled option: '$opt'." ${ERR[INTERNAL_ERROR]};;
	esac
	done
	return $(( OPTIND - 1 ))
}

set_command(){ new_command="$1"
	if [[ -n "${CMD:-}" ]]
	then
		warn "Error setting command to '$new_command': command '$CMD' has been specified by $opt."
		die "These commands are mutually exclusive: -x -j -i -I -c -C -t -T -p -P." ${ERR[BAD_OPT]}
	else
		CMD="$new_command"
	fi
}
die(){ local message=$1; declare -i exit_code=$2
	echo "$message" >&2
	exit $exit_code
}

die_hard(){ declare message="${1:-}" exit_code="${2:-1}"
	die \
		"Internal error on line $( caller | sed 's/ / of /') \
		$message" "$exit_code"
}

check_requirements(){ # args are required commands
	local required
	local -i status=0
	for required in "${@}"
	do
		if ! command -v "$required" >/dev/null
		then
			warn "Missing required command: $required"
			some_missing=1
		fi
	done
	return $status
}
generate_filename(){ local extension="$1"
	local new_basename
	if new_basename="$(
		if $USE_OFX_BASENAME
		then basename "-S.ofx" "$ofx"
		else jq -r "${_rename_format:-$_filename_format}" <<<"$json"
		fi
	)" && [[ -n "${new_basename}" ]]
	then echo "$new_basename.$extension"
	else warn "Unable to generate new filename for '$ofx'"; return 1
	fi
}
check_filename(){ local filename="$1" action="$2"
	if [[ -e "$filename" ]] && ! $FORCE_OVERWRITE
	then
		warn "Not $action: something named '$filename' already exists; skipping."
		return 1
	elif [[ -d "$filename" ]] && $FORCE_OVERWRITE
	then
		warn "Not $action to '$filename', a directory exists by that name; skipping."
		return 1
	fi
}
rename(){
	local new_filename dir
	dir="$(dirname "$ofx")"
	if new_filename="$(generate_filename ofx)" && check_filename "$dir/$new_filename" "renaming '$ofx'"
	then
		mv "$ofx" "$dir/$new_filename"
	else
		return 1
	fi
}
warn(){ local message="$1"; echo "$message" >&2; }
# shellcheck disable=SC2120  # don't be alarmed if the default fields are always used!
# capture a string to be used as the filename in case we need it
transactions()( # this needs to be a subshell because we're redirecting stdout
	if $WRITE_TO_FILE
	then
		local output_filename
		if output_filename="$(generate_filename "$TABLE_TYPE")" && check_filename "$output_filename" "writing output"
		then
			exec > "$output_filename"
		else
			return 1
		fi
	fi
	{
		local _header_fields _txn_fields _footer_fields

		_header_fields="${_transaction_headers_array}"
		_txn_fields=".TRANSACTIONS | map( . | $_transaction_fields_array ) | .[]"
		_footer_fields="${_balance_fields_array}"

		if $HASH
		then
			$HEADERS && print_rows "${_header_fields%]*},${_hash_header}]"
			print_rows "$_txn_fields" |
				mlr -N --quote-all "-$TABLE_TYPE" put "\$hash=$__hash_definition"
			$BALANCE && print_rows "${_footer_fields%]*},\"\"]"
		else
			$HEADERS && print_rows "$_header_fields"
			print_rows "$_txn_fields"
			$BALANCE && print_rows "$_footer_fields"
		fi
	}
)
print_rows(){ local _row_def="$1"
	jq -r "$_row_def | @${TABLE_TYPE}" <<<"$json" || :
}


normalize_json(){
	jq -r \
		--argjson fidir "$_fidir" \
		--arg desc_delim "$_description_deliminator" \
	'
	def add_missing_cents:
		gsub("^(?<a>-?\\d+)$";"\(.a).00") | gsub("^(?<a>-?\\d+\\.\\d)$";"\(.a)0")
	;
	def to_date_time($digits):
		($digits[0:4]+"-"+$digits[4:6]+"-"+digits[6:8]+"T"+digits[8:10]+":"+digits[10:12]+":"+digits[12:14])
	;
	def to_date($digits):
		($digits[0:4]+"-"+$digits[4:6]+"-"+digits[6:8])
	;
	def to_time_zone($digits):
		$digits | gsub("^[0-9.]*\\[";"") | gsub(":[A-Z]*\\]";"")
	;
	def add_derived_bank_names($s): $s | . + {
		BNS: $fidir[$s.INTBID].short,
		BNM: $fidir[$s.INTBID].medium,
		BNL: $fidir[$s.INTBID].long
	};
	def file_info: {
		BANKID: ((.BANKACCTFROM.BANKID // "")+(.CCACCTFROM.BANKID // "")),
		ACCTID: ((.BANKACCTFROM.ACCTID // "")+(.CCACCTFROM.ACCTID // "")),
		DTSTART: (.BANKTRANLIST.DTSTART // ""),
		DTEND: (.BANKTRANLIST.DTEND // ""),
		LEDGERBAL: (.LEDGERBAL.BALAMT // "" | add_missing_cents),
		LEDGERDT: (to_date_time(.LEDGERBAL.DTASOF // "" ) ),
		LEDGERD: (to_date(.LEDGERBAL.DTASOF // "" ) ),
		LEDGERTZ: (to_time_zone(.LEDGERBAL.DTASOF // "" ) ),
		AVAILBAL: (.AVAILBAL.BALAMT // "" | add_missing_cents),
		AVAILDT: (to_date_time(.AVAILBAL.DTASOF // "" ) ),
		AVAILD: (to_date(.AVAILBAL.DTASOF // "" ) ),
		AVAILTZ: (to_time_zone(.AVAILBAL.DTASOF // "" ) ),
		CURDEF: (.CURDEF // "")
	};
	def add_derived_file_info($s): $s | . + {
		ACCTN: ($s.ACCTID | gsub("[^A-Za-z0-9]"; "")),
		ACCTSFX: ($s.ACCTID | gsub("[^A-Za-z0-9]"; "") | .[-4:]),
		DSTART: to_date($s.DTSTART),
		TZSTART: to_time_zone($s.DTSTART),
		DTSTART: to_date_time($s.DTSTART),
		DEND: to_date($s.DTEND),
		TZEND: to_time_zone($s.DTEND),
		DTEND: to_date_time($s.DTEND)
	};
	def derived_transaction_fields: {
		DPOSTED: to_date(.DTPOSTED),
		TZPOSTED: to_time_zone(.DTPOSTED),
		DTPOSTED: to_date_time(.DTPOSTED),
		DESC: (
			if ((.NAME//"") != "" and (.MEMO//"") != "")
			then (.NAME//"") + $desc_delim + (.MEMO//"")
			else (.NAME//"") + (.MEMO//"")
			end
		),
		# in transaction amounts, add zeros for cents if missing
		TRNAMT: (
			.TRNAMT | add_missing_cents
		)
	};
	def get_intbid: { INTBID: (.SIGNONMSGSRSV1.SONRS.FI.FID // "") };
	def wrap: if type == "array" then . else [.] end;
	def first: if type == "array" then .[0] else . end;

	.OFX
	| ( add_derived_bank_names(get_intbid) ) as $props
	|
	if has("BANKMSGSRSV1") then
		( $props + { ACCTTYPE: "Bank" } ) as $props
		| .BANKMSGSRSV1.STMTTRNRS | first | .STMTRS
	elif has("CREDITCARDMSGSRSV1") then
		( $props + { ACCTTYPE: "Credit" } ) as $props
		| .CREDITCARDMSGSRSV1.CCSTMTTRNRS | first | .CCSTMTRS
	else
		error("Unknown OFX type")
	end
	| ( add_derived_file_info($props + file_info) ) as $props
	| .BANKTRANLIST
	| . += $props
	| .TRANSACTIONS=(.STMTTRN | wrap | map( . + $props + derived_transaction_fields) )
	| del(.STMTTRN)
	'
}

main "$@"
