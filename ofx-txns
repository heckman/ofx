#!/usr/bin/env bash
# Copyright (c) 2025 Erik Ben Heckman
# SPDX-License-Identifier: MIT
#
# ofx-txns
# v0.4

# parse ofx files
# and write transactions to csv/tsv files

set -x

requirements=( ofx2xml jq xq )

usage(){ echo '
Usage: ofx-txns <command> <ofx_file> [<another_ofx_file> ...]

Commands with options:

   csv       print transactions to stdout as CSV
   tsv       print transactions to stdout as TSV

   The above commands can be followed the following options.
   The filename is generated from the contents of the file.

   -w        write to file with auto-generated name rather than to stdout
   -o        write to file with same basename as ofx file
   -f        replace any existing files when writing or renaming files
   -r        rename ofx file to auto-generated name
   -H        include a header row

More commands, without options:
(Options provided for these commands will be silently ignored)

   xml       print all ofx data as xml (ofx v2)
   json      print all ofx data as json
   info      print bank, account, and date-range
   range     print range of transaction dates
   bank      print name of bank
   bnk       print shorter name of bank
   baank     print longer name of bank
   account   print account number
   rename    rename ofx file
'
}


# Add an object for each the financial institutions you use.
# They are indexed by their INTU.BID value.
# INTU.BID is a Inutuit Bank ID; the values for North-American institutions can be found here:
# https://ofx-prod-filist.intuit.com/qm2400/data/fidir.txt
_fidir='
{
  "00002": {"short": "TD",   "medium": "TD Canada Trust", "long": "Toronto Dominion Canada Trust" },
  "00004": {"short": "FK",   "medium": "FK Canada Fake",  "long": "Fakey Fake Financial Canada" },
  "00005": {"short": "CIBC", "medium": "CIBC",            "long": "Canadian Imperial Bank of Commerce" },
  "00015": {"short": "RBC",  "medium": "RBC RoyalBank",   "long": "Royal Bank of Canada" },
  "00024": {"short": "PC",   "medium": "PC Financial",    "long": "President'"'"'s Choice Financial" }
}
'



# Noe on the NAMING CONVENTION for variables: leading _ indicates the string is a fragment of jq code.



# The variables that follow define the output format.

# The following fields are usually available from an OFX file:
# (fields marked with and * are generated by this script, derived from other fields)
#
# .BANKID     The Bank ID -- a nine-digit mysterious mapping of the financial institution.
# .ACCTID     Account number as it appears in the OFX file.
# .ACCTN    * Account number with all non numbers removed, derived from ACCTID.
# .ACCTSFX  * The last 4 digits of the account number, derived from ACCTID.
# .DTSTART    Start date-and-time of included transactions.
# .DSTART   * Start date of included transactions as YYYY-MM-DD, derived from DTSTART.
# .DTEND      End date-and-time of included transactions.
# .DEND     * End date of included transactions as YYYY-MM-DD, derived from DTSTART.
# .INTBID     Intuit's Bank ID, stored in the <INTU.BID> tag.
# .BNS      * Short-form name of Bank, derived from .INTBID and bank list defined below.
# .BNM      * Short-form name of Bank, derived from .INTBID and bank list defined below.
# .BNL      * Long-form name of Bank, derived from .INTBID and bank list defined below.
#
# Additionally, the following fields are usually available for transactions:
#
# .FITID       Transaction ID, unique to each account of a financial institution.
# .DTPOSTED    Date and Time Posted.
# .DPOSTED   * Date in YYYY-MM-DD format, derived from DTPOSTED.
# .TRNTYPE     Transaction type (CREDIT, DEBIT, ATM, etc.)
# .TRNAMT      Positive for credits, negative for debits, no dollar sign.
# .NAME        The first line of the description.
# .MEMO        The second line of the description.
# .DESC      * Description, derived from NAME and MEMO, which, when both are non-empty,
#              are joined by a delimiter defined below. (If either is empty then
#              they are joined without a delimiter.)
_description_deliminator='; '
# _description_deliminator='
# '

# these are used for the info command and when (re)naming files
_filename_format='.BNS + "-" + .ACCTSFX + " -- " + (.DSTART | gsub("-(?<d>\\d\\d)$"; "\(.d)")) + " - " + (.DEND | gsub("-(?<d>\\d\\d)$"; "\(.d)"))'

# this jq array is used to define the headers for the transaction fields:
_default_transaction_field_headers='[
	"ACCOUNT",
	"TRANSACTION ID",
	"DATE POSTED",
	"TYPE",
	"DESCRIPTION",
	"AMOUNT"
]'

# this jq array specifies fields to include for transactions:
_default_transaction_fields='[
	(.BNS + "-" + .ACCTSFX),
	.FITID,
	.DPOSTED,
	.TRNTYPE,
	.DESC,
	.TRNAMT
]'

_default_info_string='.BNL + ", account " + .ACCTID + ", from " + .DSTART + " to " + .DEND + "."'
_default_range_string='.DSTART + " to " + .DEND'



# default options, can be modified by command-line options
WRITE_TO_FILE=false
NAME_LIKE_OFX=false
FORCE_OVERWRITE=false
RENAME_OFX=false
HEADERS=false

# error exit codes
declare -Air ERR=(
	[BAD_OPT]=2 # invalid command-line option
	[NO_ARG]=3  # command-line option missing required argument
	[NO_CMD]=4  # no command specified
	[BAD_CMD]=5 # invalid command specified
	[PANIC]=8 # generic internal error; this should never happen
	[INTERNAL_ERROR]=9 # these should not happen
	[FILE_EXISTS]=12 # file already exists and not overwriting
	[BAD_FILE]=13 # file doesn't exist or is not readable
	[MISSING_REQUIREMENT]=14
)

set -euo pipefail

# this is a global variable containing the path to the current OFX file
declare ofx


main(){
	check_requirements
	parse_options "$@" || shift $?
	local cmd
	case "${1:-}" in
		xml|json|csv|tsv|info|range|bank|bnk|baank|account|rename) cmd="$1";;
		"") die "No command specified. Use -h for help." ${ERR[NO_CMD]};;
		*) die "Unknown command '$1'. Use -h for help." ${ERR[BAD_CMD]};;
	esac
	shift
	parse_options "$@" || shift $?
	echo "$@" >&2
	for ofx in "$@"; do
		echo "Processing: $ofx" >&2
		[[ -f "$ofx" ]] || die "File not found: $ofx" ${ERR[BAD_FILE]}
		[[ -r "$ofx" ]] || die "Can't read file: $ofx" ${ERR[BAD_FILE]}
		case "$cmd" in
		xml) xml;;
		json) xml | xq -j | cat;;
		csv) tabular csv;;
		tsv) tabular tsv;;
		info) info "$_default_info_string" ;;
		range) info "$_default_range_string";;
		bank) info '.BNM';;
		bnk) info '.BNS';;
		baank) info '.BNL';;
		account) info '.ACCTID';;
		rename) rename "$(info "$_filename_format")";;
		*) die "Unconfigured commmand: '$cmd'." ${ERR[INTERNAL_ERROR]};;
		esac
	done
}

parse_options(){
	if [[ "${1:--help}" == '--help' ]]; then usage; exit 0; fi
	while getopts ":hwofrH" opt
	do
		case "$opt" in
		h) usage; exit 0;;
		w) WRITE_TO_FILE=true;;
		o) WRITE_TO_FILE=true; NAME_LIKE_OFX=true;;
		f) FORCE_OVERWRITE=true;;
		r) RENAME_OFX=true;;
		H) HEADERS=true;;
		:) die "Option -$OPTARG requires an argument" ${ERR[NO_ARG]};;
		\?) die "Invalid option: -$OPTARG" ${ERR[BAD_OPT]};;
		*) die_hard "Unhandled option: '$opt'." ${ERR[INTERNAL_ERROR]};;
		esac
	done
	return $(( OPTIND - 1 ))
}

die(){ local message=$1; declare -i exit_code=$2
	echo "$message" >&2
	exit $exit_code
}

die_hard(){ declare -i message=$1 exit_code=$2
	die \
		"Internal error on line $( caller | sed 's/ / of /') \
		$message" $exit_code
}

check_requirements(){
	local required
	for required in "${requirements[@]}"
	do command -v "$required" >/dev/null ||
		die \
			"Missing required command: $required" \
			${ERR[MISSING_REQUIREMENT]}
	done
}

rename(){
	local new_filename="$1.ofx"
	if [[ -e "$new_filename" ]] && ! $FORCE_OVERWRITE
	then
		# die "File already exists: $new_filename" ${ERR[FILE_EXISTS]}
		echo "File '$new_filename' already exists, skipping." >&2
	else
		mv "$ofx" "$new_filename"
	fi
}

# shellcheck disable=SC2120  # don't be alarmed if the default fields are always used!
# capture a string to be used as the filename in case we need it
tabular(){ local _table_format="${1}";
	parse "$_filename_format" "$_default_transaction_fields | @${_table_format}" | {
		read -r info_string
		if $WRITE_TO_FILE
		then
			if $NAME_LIKE_OFX
			then
				filename="$(basename -s.ofx "$ofx").${_table_format}"
			else
				filename="${info_string}.${_table_format}"
			fi
			if [[ -e "$filename" ]] && ! $FORCE_OVERWRITE
			then die "Error: $filename already exists." ${ERR[FILE_EXISTS]}
			else
				{
					if $HEADERS; then headers "${_table_format}"; fi
					cat -
				} > "$filename"
			fi
		else
			if $HEADERS; then headers "${_table_format}"; fi
			cat -
		fi
		if $RENAME_OFX; then rename "$info_string"; fi
	}
}

xml(){
	ofx2xml "$ofx"
}
json(){
	xml | xq -j | cat  # `cat` prevents output from being interactive (which causes errors for ofx2xml)
}
info(){ parse "$1" | head -n 1; }

headers(){ local _table_format="${1}";
	jq -r ". | @${_table_format}" <<<"$_default_transaction_field_headers"
}

# derives json then outputs, on the first line, summary info,
# then, on the subsequent lines, transaction info
parse(){
	local _info_format="${1:-\"\"}"
	local _txn_format="${2:-\"\"}"
	# shellcheck disable=SC2016 # the dollarsigns are jq variables
	json | jq -r --argjson fidir "$_fidir" '
	.OFX
	| ({ INTBID: (.SIGNONMSGSRSV1.SONRS.FI.FID // "") }) as $props
	| ( $props + '"$_derived_bank_names"' )	as $props
	| if has("BANKMSGSRSV1") then .BANKMSGSRSV1.STMTTRNRS
		| if type == "array" then .[0] else . end
		| .STMTRS
	elif has("CREDITCARDMSGSRSV1") then .CREDITCARDMSGSRSV1.CCSTMTTRNRS
		| if type == "array" then .[0] else . end
		| .CCSTMTRS
	else
		error("Unknown OFX type")
	end
	| ( $props + '"$_file_info"' ) as $props
	| ( $props + '"$_derived_file_info"' ) as $props
	| .BANKTRANLIST
	| (
		( . + $props | '"$_info_format"' ),
		(
			.STMTTRN | if type == "array" then . else [.] end
			| .[]
			| . + '"$_derived_transaction_fields"'
			| . + $props
			| '"$_txn_format"'
		)
	)
	'
}

# shellcheck disable=SC2016 # the dollarsigns are jq variables
_derived_bank_names='{
	BNS: $fidir[$props.INTBID].short,
	BNM: $fidir[$props.INTBID].medium,
	BNL: $fidir[$props.INTBID].long
}'
_file_info='{
	BANKID: ((.BANKACCTFROM.BANKID // "")+(.CCACCTFROM.BANKID // "")),
	ACCTID: ((.BANKACCTFROM.ACCTID // "")+(.CCACCTFROM.ACCTID // "")),
	DTSTART: (.BANKTRANLIST.DTSTART // ""),
	DTEND: (.BANKTRANLIST.DTEND // "")
}'
# shellcheck disable=SC2016 # the dollarsigns are jq variables
_derived_file_info='{
	ACCTN: ($props.ACCTID | gsub("[^A-Za-z0-9]"; "")),
	ACCTSFX: ($props.ACCTID | gsub("[^A-Za-z0-9]"; "") | .[-4:]),
	DSTART: ($props.DTSTART[0:4]+"-"+$props.DTSTART[4:6]+"-"+$props.DTSTART[6:8]),
	DEND: ($props.DTEND[0:4]+"-"+$props.DTEND[4:6]+"-"+$props.DTEND[6:8])
}'
_derived_transaction_fields='{
	DPOSTED: (
		.DTPOSTED[0:4]+"-"+.DTPOSTED[4:6]+"-"+.DTPOSTED[6:8]
	),
	DESC: (
		if ((.NAME//"") != "" and (.MEMO//"") != "")
		then (.NAME//"") + "'"$_description_deliminator"'" + (.MEMO//"")
		else (.NAME//"") + (.MEMO//"")
		end
	),
	# in transaction amounts, add zeros for cents if missing
	TRNAMT: (
		.TRNAMT
		| gsub("^(?<a>-?\\d+)$";"\(.a).00")
		| gsub("^(?<a>-?\\d+\\.\\d)$";"\(.a)0")
	)
}'



main "$@"
