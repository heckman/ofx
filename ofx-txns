#!/usr/bin/env bash
# Copyright (c) 2025 Erik Ben Heckman
# SPDX-License-Identifier: MIT
#
# ofx-txns
# v0.4

# parse ofx files
# and write transactions to csv/tsv files

# set -x
set -eu #o pipefail

requirements=( ofx2xml jq xq )

usage(){ echo '
Usage: ofx-txns <command> <ofx_file> [<another_ofx_file> ...]

Commands with options:

   csv       print transactions to stdout as CSV
   tsv       print transactions to stdout as TSV

   The above commands can be followed the following options.
   The filename is generated from the contents of the file.

   -w        write to file with auto-generated name rather than to stdout
   -o        write to file with same basename as ofx file
   -f        replace any existing files when writing or renaming files
   -r        rename ofx file to auto-generated name
   -H        include a header row

More commands, without options:
(Options provided for these commands will be silently ignored)

   xml       print all ofx data as xml (ofx v2)
   json      print all ofx data as json
   info      print bank, account, and date-range
   range     print range of transaction dates
   bank      print name of bank
   bnk       print shorter name of bank
   baank     print longer name of bank
   account   print account number
   rename    rename ofx file
'
}


# Add an object for each the financial institutions you use.
# They are indexed by their INTU.BID value.
# INTU.BID is a Inutuit Bank ID; the values for North-American institutions can be found here:
# https://ofx-prod-filist.intuit.com/qm2400/data/fidir.txt
_fidir='
{
  "00002": {"short": "TD",   "medium": "TD Canada Trust", "long": "Toronto Dominion Canada Trust" },
  "00004": {"short": "FK",   "medium": "FK Canada Fake",  "long": "Fakey Fake Financial Canada" },
  "00005": {"short": "CIBC", "medium": "CIBC",            "long": "Canadian Imperial Bank of Commerce" },
  "00015": {"short": "RBC",  "medium": "RBC RoyalBank",   "long": "Royal Bank of Canada" },
  "00024": {"short": "PC",   "medium": "PC Financial",    "long": "President'"'"'s Choice Financial" }
}
'



# Noe on the NAMING CONVENTION for variables: leading _ indicates the string is a fragment of jq code.



# The variables that follow define the output format.

# The following fields are usually available from an OFX file:
# (fields marked with and * are generated by this script, derived from other fields)
#
# .INTBID     Intuit's Bank ID, stored in the <INTU.BID> tag.
# .BNS      * Short-form name of Bank, derived from .INTBID and bank list defined below.
# .BNM      * Short-form name of Bank, derived from .INTBID and bank list defined below.
# .BNL      * Long-form name of Bank, derived from .INTBID and bank list defined below.
# .BANKID     A nine-digit number, supposed to be a routing number, but often not.
# .ACCTID     Account number as it appears in the OFX file.
# .ACCTN    * Account number with all non numbers removed, derived from ACCTID.
# .ACCTSFX  * The last 4 digits of the account number, derived from ACCTID.
# .ACCTTYPE   Type of account, one of: Bank, Credit.
# .DSTART   * Start date of included transactions as YYYY-MM-DD, derived from DTSTART.
# .DTSTART  * Start date of included transactions without time zone or sub-seconds.
# .TZSTART  * Tome sone of start date-time of included transactions.
# .DEND     * End date of included transactions as YYYY-MM-DD, derived from DTEND.
# .DTEND    * End date-time of included transactions without time zone or sub-seconds.
# .TZEND    * Tome sone of end date-time of included transactions.
# .LEDGERBAL  The account balance at the end date of transactions.
# .LEDGERD  * The date of the account balance as YYYY-MM-DD, derived from .LEDGERDT
# .LEDGERDT * The date-time of the account balance without time zone or sub-seconds.
# .LEDGERTZ * The time zone of the account balance.
# .AVAILBAL   The available balance at the end date of transactions.
# .AVAILD   * The date of the available balance as YYYY-MM-DD, derived from .AVAILDT
# .AVAILDT  * The date-time of the available balance without time zone or sub-seconds.
# .AVAILTZ  * The time zone of the available balance.
# .CURDEF     The currency code of the account.
#
# Additionally, the following fields are usually available for transactions:
#
# .FITID       Transaction ID, should be unique to each account of a financial institution.
# .DPOSTED   * Date in YYYY-MM-DD format, derived from DTPOSTED.
# .DTPOSTED  * original .DTPOSTED with sub-seconds and time zone removed.
# .TZPOSTED  * Time Zone of DTPOSTED.
# .TRNTYPE     Transaction type (CREDIT, DEBIT, ATM, etc.)
# .TRNAMT      Positive for credits, negative for debits, no dollar sign.
# .NAME        The first line of the description.
# .MEMO        The second line of the description.
# .DESC      * Description, derived from NAME and MEMO, which, when both are non-empty,
#              are joined by a delimiter defined below. (If either is empty then
#              they are joined without a delimiter.)
_description_deliminator='; '
# _description_deliminator='
# '

# format used for (re)naming files
#
_filename_format='
	.BNS + "-" + .ACCTSFX + " transactions from " + .DSTART + " to " + .DEND
'
# another option for a more-compact filename
# _filename_format='
# .BNS + "-" + .ACCTSFX + " -- "
# + (.DSTART | gsub("-(?<d>\\d\\d)$"; "\(.d)"))
# + " - "
# + (.DEND | gsub("-(?<d>\\d\\d)$"; "\(.d)"))
# '

# format of info string
#
_info_format='
	.BNL + ", account " + .ACCTID + ", from " +
	.DSTART + " to " + .DEND + "."'

# format of range string
#
_range_format='.DSTART + " to " + .DEND'


# two jq arrays specifiy fields to include for transactions, and their headers
#
### with separate fields for withdrawals and deposits
# _transaction_headers_array='
# 	[
# 		"ACCOUNT",
# 		"DATE POSTED",
# 		"DESCRIPTION",
# 		"WITHDRAWALS",
# 		"DEPOSITS"
# 	]
# '
# _transaction_fields_array='
# 	[
# 		(.BNS + "-" + .ACCTSFX),
# 		.DPOSTED,
# 		.DESC,
# 		(if .TRNAMT[0:1]=="-" then .TRNAMT[1:] else "" end),
# 		(if .TRNAMT[0:1]=="-" then "" else .TRNAMT end)
# 	]
# '
# # No good place to put the word "Balance"
# # (don't want to put value in WITHDRWALS or DEPOSITS)
# _balance_fields_array='
# 	[
#		(.BNS + "-" + .ACCTSFX),
#		.LEDGERD,
#		.LEDGERBAL,
#		"",
#		""
# 	]
#'
#
#### a simpler set of fields with single field for amount
# _transaction_headers_array='
# 	[
# 		"ACCOUNT",
# 		"DATE POSTED",
# 		"DESCRIPTION",
# 		"AMOUNT"
# 	]
# '
# _transaction_fields_array='
# 	[
# 		(.BNS + "-" + .ACCTSFX),
# 		.DPOSTED,
# 		.DESC,
# 		.TRNAMT
# 	]
# '
# # No good place to put the word "Balance"
# # (don't want to put value in the AMOUNT column)
# _balance_fields_array='
# 	[
#		(.BNS + "-" + .ACCTSFX),
#		.LEDGERD,
#		.LEDGERBAL,
#		""
# 	]
#'
#### my personal default selection
_transaction_headers_array='
	[
		"ACCOUNT",
		"ID",
		"DATE POSTED",
		"DESCRIPTION",
		"AMOUNT",
		"CURRENCY"
	]
'
_transaction_fields_array='
	[
		(.BNS + "-" + .ACCTSFX),
		.FITID,
		.DPOSTED,
		.DESC,
		.TRNAMT,
		.CURDEF
	]
'
# format for the optional ballance record
_balance_fields_array='
	[
		(.BNS + "-" + .ACCTSFX),
		"BALANCE",
		.LEDGERD,
		.LEDGERBAL,
		"",
		.CURDEF
	]
'
### includes all fields almost-always included
# _transaction_headers_array='
# 	[
# 		"ACCOUNT",
# 		"TRANSACTION ID",
# 		"DATE-TIME POSTED",
# 		"TIME-ZONE POSTED",
# 		"TYPE",
# 		"NAME",
# 		"MEMO",
# 		"AMOUNT",
# 		"CURRENCY"
# 	]
# '
# _transaction_fields_array='
# 	[
# 		(.BNS + "-" + .ACCTSFX),
# 		.FITID,
# 		.DTPOSTED,
# 		.TZPOSTED,
# 		.TRNTYPE,
# 		.NAME,
# 		.MEMO,
# 		.TRNAMT,
# 		.CURDEF
# 	]
# '
# _balance_fields_array='
# 	[
# 		(.BNS + "-" + .ACCTSFX),
# 		"BALANCE",
# 		.LEDGERDT,
# 		.LEDGERTZ,
# 		"BALANCE",
# 		"",
# 		.LEDGERBAL,
# 		"",
# 		.CURDEF
# 	]
# '




# default options, can be modified by command-line options
WRITE_TO_FILE=false
NAME_LIKE_OFX=false
FORCE_OVERWRITE=false
RENAME_OFX=false
HEADERS=false
BALANCE=false
HASH=false
_hash_header='"HASH"'

# error exit codes
declare -Air ERR=(
	[BAD_OPT]=2 # invalid command-line option
	[NO_ARG]=3  # command-line option missing required argument
	[NO_CMD]=4  # no command specified
	[BAD_CMD]=5 # invalid command specified
	[PANIC]=8 # generic internal error; this should never happen
	[INTERNAL_ERROR]=9 # these should not happen
	[FILE_EXISTS]=12 # file already exists and not overwriting
	[BAD_FILE]=13 # file doesn't exist or is not readable
	[MISSING_REQUIREMENT]=14
)


# this is a global variable containing the path to the current OFX file
declare ofx


main(){
	check_requirements
	parse_options "$@" || shift $?
	local cmd
	case "${1:-}" in
		xml|json|csv|tsv|info|range|bank|bnk|baank|account|rename) cmd="$1";;
		"") die "No command specified. Use -h for help." ${ERR[NO_CMD]};;
		*) die "Unknown command '$1'. Use -h for help." ${ERR[BAD_CMD]};;
	esac
	shift
	parse_options "$@" || shift $?
	for ofx in "$@"; do
		# echo "Processing '$ofx'."; continue
		[[ -f "$ofx" ]] || die "File not found: $ofx" ${ERR[BAD_FILE]}
		[[ -r "$ofx" ]] || die "Can't read file: $ofx" ${ERR[BAD_FILE]}
		case "$cmd" in
		xml) xml;;
		json) xml | xq -j | cat;;
		csv) tabular csv;;
		tsv) tabular tsv;;
		info) info "$_info_format" ;;
		range) info "$_range_format";;
		bank) info '.BNM';;
		bnk) info '.BNS';;
		baank) info '.BNL';;
		account) info '.ACCTID';;
		rename) rename "$(info "$_filename_format")";;
		*) die "Unconfigured commmand: '$cmd'." ${ERR[INTERNAL_ERROR]};;
		esac
	done
}

parse_options(){
	if [[ "${1:--help}" == '--help' ]]; then usage; exit 0; fi
	while getopts ":hwofC:bB:mM:rR:tT:F:" opt
	do
		case "$opt" in
		h) usage; exit 0;;
		F) _info_format="$OPTARG"; _filename_format="$OPTARG";;
		C) _transaction_fields_array="$OPTARG";;
		t) HEADERS=true;;
		T) _transaction_headers_array="$OPTARG";;
		r) RENAME_OFX=true;;
		R) RENAME_OFX=true; _filename_format="$OPTARG";;
		b) BALANCE=true;;
		B) BALANCE=true; _balance_fields_array="$OPTARG";;
		m) HASH=true;;
		M) HASH=true; _hash_header="$OPTARG";;
		w) WRITE_TO_FILE=true;;
		o) WRITE_TO_FILE=true; NAME_LIKE_OFX=true;;
		f) FORCE_OVERWRITE=true;;
		:) die "Option -$OPTARG requires an argument" ${ERR[NO_ARG]};;
		\?) die "Invalid option: -$OPTARG" ${ERR[BAD_OPT]};;
		*) die_hard "Unhandled option: '$opt'." ${ERR[INTERNAL_ERROR]};;
		esac
	done
	return $(( OPTIND - 1 ))
}

die(){ local message=$1; declare -i exit_code=$2
	echo "$message" >&2
	exit $exit_code
}

die_hard(){ declare message="${1:-}" exit_code="${2:-1}"
	die \
		"Internal error on line $( caller | sed 's/ / of /') \
		$message" "$exit_code"
}

check_requirements(){
	local required
	for required in "${requirements[@]}"
	do command -v "$required" >/dev/null ||
		die \
			"Missing required command: $required" \
			${ERR[MISSING_REQUIREMENT]}
	done
}

rename(){
	if [[ -z "${1:-}" ]]
	then
		echo "Unable to generate new filename for '$ofx'; skipping." >&2
		return 1
	fi
	local new_filename="$1.ofx"
	if [[ -e "$new_filename" ]] && ! $FORCE_OVERWRITE
	then
		echo "Not renaming '$ofx': something named '$new_filename' already exists; skipping." >&2
		return 1
	fi
	mv "$ofx" "$new_filename"
}

# shellcheck disable=SC2120  # don't be alarmed if the default fields are always used!
# capture a string to be used as the filename in case we need it
tabular(){ local _table_format="${1}";
	parse "$_filename_format" "$_transaction_fields_array | @${_table_format}" | {
		read -r basefilename
		{
			if $HEADERS; then headers "${_table_format}"; fi
			if $HASH; then cat - | add_hash; else cat -;fi
			if $BALANCE; then balance "${_table_format}"; fi
		} | {
			if $WRITE_TO_FILE
			then
				if $NAME_LIKE_OFX
				then
					basefilename="$(basename -s.ofx "$ofx")"
				fi
				if [[ -z "$basefilename" ]]
				then
					echo "Problem generating output filename for '$ofx'; skipping,." >&2
					return 1
				fi
				filename="$basefilename.${_table_format}"
				if [[ -e "$filename" ]] && ! $FORCE_OVERWRITE
				then
					echo "File '$filename' already exists; skipping '$ofx'." >&2
					return 1
				fi
				cat - > "$filename"
			else
				cat -
			fi
		}
		if $RENAME_OFX; then rename "$basefilename"; fi
	}
}

xml(){
	ofx2xml "$ofx"
}
json(){
	xml | xq -j | cat  # `cat` prevents output from being interactive (which causes errors for ofx2xml)
}
info(){ parse "$1" | head -n 1; }

headers(){ local _table_format="${1}" _fields
	if $HASH
	then _fields="${_transaction_headers_array%]*},${_hash_header}]"
	else _fields="${_transaction_headers_array}"
	fi
	jq -r ". | @${_table_format}" <<<"$_fields"
}
balance(){ local _table_format="${1}" _fields
	if $HASH
	then _fields="${_balance_fields_array%]*}"',""]'
	else _fields="${_balance_fields_array}"
	fi
	info "$_fields | @${_table_format}"
}
add_hash(){
	while read -r line
	do
		if [[ -n "$line" ]]
		then
			echo "$line,\"$(
				md5 <<<"$line" |
				sed -Ee 's/(....)/\1-/g' -e 's/-$//'
			)\""
		fi
	done
}

# derives json then outputs, on the first line, summary info,
# then, on the subsequent lines, transaction info
parse(){
	local _info_format="${1:-.}"
	local _txns_format="${2:-.}"
	# shellcheck disable=SC2016 # the dollarsigns are jq variables
	json | jq -r \
		--argjson fidir "$_fidir" \
		--arg desc_delim "$_description_deliminator" \
	"
	def txns_fmt: $_txns_format;
	def info_fmt: $_info_format;
	"'
	def add_missing_cents:
		gsub("^(?<a>-?\\d+)$";"\(.a).00") | gsub("^(?<a>-?\\d+\\.\\d)$";"\(.a)0")
	;
	def to_date_time($digits):
		($digits[0:4]+"-"+$digits[4:6]+"-"+digits[6:8]+"T"+digits[8:10]+":"+digits[10:12]+":"+digits[12:14])
	;
	def to_date($digits):
		($digits[0:4]+"-"+$digits[4:6]+"-"+digits[6:8])
	;
	def to_time_zone($digits):
		$digits | gsub("^[0-9.]*\\[";"") | gsub(":[A-Z]*\\]";"")
	;
	def add_derived_bank_names($s): $s | . + {
		BNS: $fidir[$s.INTBID].short,
		BNM: $fidir[$s.INTBID].medium,
		BNL: $fidir[$s.INTBID].long
	};
	def file_info: {
		BANKID: ((.BANKACCTFROM.BANKID // "")+(.CCACCTFROM.BANKID // "")),
		ACCTID: ((.BANKACCTFROM.ACCTID // "")+(.CCACCTFROM.ACCTID // "")),
		DTSTART: (.BANKTRANLIST.DTSTART // ""),
		DTEND: (.BANKTRANLIST.DTEND // ""),
		LEDGERBAL: (.LEDGERBAL.BALAMT // "" | add_missing_cents),
		LEDGERDT: (to_date_time(.LEDGERBAL.DTASOF // "" ) ),
		LEDGERD: (to_date(.LEDGERBAL.DTASOF // "" ) ),
		LEDGERTZ: (to_time_zone(.LEDGERBAL.DTASOF // "" ) ),
		AVAILBAL: (.AVAILBAL.BALAMT // "" | add_missing_cents),
		AVAILDT: (to_date_time(.AVAILBAL.DTASOF // "" ) ),
		AVAILD: (to_date(.AVAILBAL.DTASOF // "" ) ),
		AVAILTZ: (to_time_zone(.AVAILBAL.DTASOF // "" ) ),
		CURDEF: (.CURDEF // "")
	};
	def add_derived_file_info($s): $s | . + {
		ACCTN: ($s.ACCTID | gsub("[^A-Za-z0-9]"; "")),
		ACCTSFX: ($s.ACCTID | gsub("[^A-Za-z0-9]"; "") | .[-4:]),
		DSTART: to_date($s.DTSTART),
		TZSTART: to_time_zone($s.DTSTART),
		DTSTART: to_date_time($s.DTSTART),
		DEND: to_date($s.DTEND),
		TZEND: to_time_zone($s.DTEND),
		DTEND: to_date_time($s.DTEND)
	};
	def derived_transaction_fields: {
		DPOSTED: to_date(.DTPOSTED),
		TZPOSTED: to_time_zone(.DTPOSTED),
		DTPOSTED: to_date_time(.DTPOSTED),
		DESC: (
			if ((.NAME//"") != "" and (.MEMO//"") != "")
			then (.NAME//"") + $desc_delim + (.MEMO//"")
			else (.NAME//"") + (.MEMO//"")
			end
		),
		# in transaction amounts, add zeros for cents if missing
		TRNAMT: (
			.TRNAMT | add_missing_cents
		)
	};
	def get_intbid: { INTBID: (.SIGNONMSGSRSV1.SONRS.FI.FID // "") };
	def wrap: if type == "array" then . else [.] end;
	def first: if type == "array" then .[0] else . end;

	.OFX
	| ( add_derived_bank_names(get_intbid) ) as $props
	|
	if has("BANKMSGSRSV1") then
		( $props + { ACCTTYPE: "Bank" } ) as $props
		| .BANKMSGSRSV1.STMTTRNRS | first | .STMTRS
	elif has("CREDITCARDMSGSRSV1") then
		( $props + { ACCTTYPE: "Credit" } ) as $props
		| .CREDITCARDMSGSRSV1.CCSTMTTRNRS | first | .CCSTMTRS
	else
		error("Unknown OFX type")
	end
	| ( add_derived_file_info($props + file_info) ) as $props
	| .BANKTRANLIST
	| (
		( . + $props | info_fmt ),
		(
			.STMTTRN | wrap
			| .[]
			| . + $props
			| . + derived_transaction_fields
			| txns_fmt
		)
	)
	'
}

main "$@"
