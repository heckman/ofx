#!/usr/bin/env bash
# ofx
# v0.2.3

usage(){ echo '
Usage: ofx <command> <ofx_file>

Commands:
   xml      print ofx data as xml (ofx v2)
   json     print ofx data as json
   csv      print transactions as CSV
   csv1     print transactions as CSV with headers
   info     print bank, account, and range info
   range    print range of transaction dates
   bank     print name of bank
   bnk      print short name of bank
   account  print account number
   headers  print header row for CSV transactions
'
}

# The following fields are usually available from an OFX file:
# (fields marked with and * are generated by this script, derived from other fields)
#
# .BANKID     The Bank ID -- a nine-digit mysterious mapping of the financial institution.
# .ACCTID     Account number as it appears in the OFX file.
# .ACCTN    * Account number with all non numbers removed, derived from ACCTID.
# .ACCTSFX  * The last 4 digits of the account number, derived from ACCTID.
# .DTSTART    Start date-and-time of included transactions.
# .DSTART   * Start date of included transactions as YYYY-MM-DD, derived from DTSTART.
# .DTEND      End date-and-time of included transactions.
# .DEND     * End date of included transactions as YYYY-MM-DD, derived from DTSTART.
# .INTBID     Intuit's Bank ID, stored in the <INTU.BID> tag.
# .BNS      * Short-form name of Bank, derived from .INTBID and bank list defined below.
# .BNM      * Short-form name of Bank, derived from .INTBID and bank list defined below.
# .BNL      * Long-form name of Bank, derived from .INTBID and bank list defined below.
#
# Additionally, the following fields are usually available for transactions:
#
# .FITID       Transaction ID, unique to each account of a financial institution.
# .DTPOSTED    Date and Time Posted.
# .DPOSTED   * Date in YYYY-MM-DD format, derived from DTPOSTED.
# .TRNTYPE     Transaction type (CREDIT, DEBIT, ATM, etc.)
# .TRNAMT      Positive for credits, negative for debits, no dollar sign.
# .NAME        The first line of the description.
# .MEMO        The second line of the description.
# .DESC      * Description, derived from NAME and MEMO, which, when both are non-empty,
#              are joined by a delimiter defined below. (If either is empty then
#              they are joined without a delimiter.)
_description_deliminator='; '
# _description_deliminator='
# '

# Add an object for each the financial institutions you use.
# They are indexed by their INTU.BID value.
# INTU.BID is a Inutuit Bank ID; the values for North-American institutions can be found here:
# https://ofx-prod-filist.intuit.com/qm2400/data/fidir.txt
read -r -d "" _fidir <<'EOF'
{
  "00002": {"short": "TD",   "medium": "TD Canada Trust", "long": "Toronto Dominion Canada Trust" },
  "00004": {"short": "FK",   "medium": "FK Canada Fake", "long": "Fakey Fake Financial Canada" },
  "00005": {"short": "CIBC", "medium": "CIBC",            "long": "Canadian Imperial Bank of Commerce" },
  "00015": {"short": "RBC",  "medium": "RBC RoyalBank",   "long": "Royal Bank of Canada" },
  "00024": {"short": "PC",   "medium": "PC Financial",    "long": "President's Choice Financial" }
}
EOF

# a NOTE on the naming conventions
#
#   An underscore will be used to prefix names of
#   - variables containing fragments of jq code,
#   - functions that generate fragments of jq code

# PROGRESS NOTES:
#
# this version of the script creates a lot of custom "fields" in jq
# which can be strung together to produce various outputs
# the commands provide various presets
#
# this script preprocesses the OFX file to extract the INTU.BID,
# which is lost when converting the OFX to XML (OFX 2.0)
# it is then injected into the jq script as a variable,
# along with values for the bank name and initials.

# 2.1 :
# - inject INTU.BID into XML by changing <INTU.BID> to <FI><FID>
#   doing it this way will prevent the need to read the file twice,
#   and instead process it as a single strem.
# 2.2 :
# - just clean up the code a bit

# TODO:
# - provide a way to customize output
# - provide the ability to create well-named csv files
# - provide a way to rename ofx files

_account_identifier='.BNS + "-" + .ACCTSFX'
_date_range='.DSTART + " to " + .DEND'
_default_info_format="$_account_identifier + \" from \" + $_date_range"

# these are not used anywhere yet:
_default_transaction_field_headers='[
	"ACCOUNT",
	"TRANSACTION ID",
	"DATE POSTED",
	"TYPE",
	"DESCRIPTION",
	"AMOUNT"
]'
_default_transaction_fields="[
	$_account_identifier,
	.FITID,
	.DPOSTED,
	.TRNTYPE,
	.DESC,
	.TRNAMT
]"

# shellcheck disable=SC2016  # these variables are expanded by jq
_stashed_vars='{
	BANKID: $bank_id,
	ACCTID: $account_number,
	ACCTN: $account_number_only_digits,
	ACCTSFX: $account_suffix,
	DTSTART: $datetime_start,
	DSTART:  $date_start,
	DTEND: $datetime_end,
	DEND: $date_end,
	INTBID: $intu_bid,
	BNS: $fidir[$intu_bid].short,
	BNM: $fidir[$intu_bid].medium,
	BNL: $fidir[$intu_bid].long
}'

_derived_txn_vars='{
	DPOSTED: (
		.DTPOSTED[0:4]+"-"+.DTPOSTED[4:6]+"-"+.DTPOSTED[6:8]
	),
	DESC: (
		if ((.NAME//"") != "" and (.MEMO//"") != "")
		then (.NAME//"") + "'"$_description_deliminator"'" + (.MEMO//"")
		else (.NAME//"") + (.MEMO//"")
		end
	),
	TRNAMT: ( # add zeros for cents if missing
		.TRNAMT
		| gsub("^(?<a>-?\\d+)$";"\(.a).00")
		| gsub("^(?<a>-?\\d+\\.\\d)$";"\(.a)0")
	)
}'

# shellcheck disable=SC2016  # dollarsigns are preserved for jq
# once we get to the transaction list,
# we have access to the start and end dates of the transaction list.
_to_transaction_list='
	.OFX
	| (.SIGNONMSGSRSV1.SONRS.FI.FID // "") as $intu_bid
	| if has("BANKMSGSRSV1") then .BANKMSGSRSV1.STMTTRNRS
		| if type == "array" then .[0] else . end
		| .STMTRS
	elif has("CREDITCARDMSGSRSV1") then .CREDITCARDMSGSRSV1.CCSTMTTRNRS
		| if type == "array" then .[0] else . end
		| .CCSTMTRS
	else
		error("Unknown OFX type")
	end
	| ((.BANKACCTFROM.BANKID // "")+(.CCACCTFROM.BANKID // "")) as $bank_id
	| ((.BANKACCTFROM.ACCTID // "")+(.CCACCTFROM.ACCTID // "")) as $account_number
	| ( $account_number | gsub("[^A-Za-z0-9]"; "") ) as $account_number_only_digits
	| ( $account_number_only_digits[-4:] ) as $account_suffix
	| .BANKTRANLIST
	| (.DTSTART // "") as $datetime_start
	| ($datetime_start[0:4]+"-"+$datetime_start[4:6]+"-"+$datetime_start[6:8]) as $date_start
	| (.DTEND // "") as $datetime_end
	| ($datetime_end[0:4]+"-"+$datetime_end[4:6]+"-"+$datetime_end[6:8]) as $date_end
'
_each_transaction='
	.STMTTRN | if type == "array" then . else [.] end
	| .[]
	| . + '"$_derived_txn_vars"


# this is a global variable containing the path to the OFX file
declare ofx

main(){
	local cmd="${1:-}"; shift
	[[ "$cmd" == "headers" ]] && { headers; return; }
	for ofx in "$@"; do
		[[ -f "$ofx" ]] || { usage >&2; exit 69; }
		[[ -r "$ofx" ]] || { usage >&2; exit 69; }
		case "$cmd" in
		xml) xml;;
		json) json;;
		csv|trans|transactions) csv;;
		csv1) headers; csv;;
		range) info "$_date_range";;
		bank) info '.BNM';;
		bnk) info '.BNS';;
		info) info;;
		account) info "$_account_identifier";;
		headers) headers;;
		*) usage >&2; exit 69;;
		esac
	done
}

xml(){
	ofx2xml "$ofx"
}
json(){
	xml | xq -j | cat  # `cat` prevents output from being interactive (which causes errors for ofx2xml)
}

# derives json then outputs , on the first line, summary info,
# then, on the subsequent lines, transaction info
parse(){
	local _info_format="${1:-$_default_info_format}"
	local _txn_format="${2:-$_default_transaction_fields} | @csv"
	ofxq  "
	 	$_to_transaction_list
		| (
			( . + $_stashed_vars | $_info_format ),
			(
				$_each_transaction
				| . + $_stashed_vars
				| $_txn_format
			)
		)
	"
}

ofxq(){
	json | jq -r --argjson fidir "$_fidir" "$@"
}

info(){ parse "${1:-}" "${2:-}" | head -n 1; }

# shellcheck disable=SC2120  # don't be alarmed if the default fields are always used!
csv(){ parse "${1:-}" "${2:-}" | tail -n +2; }

headers(){
	jq -r '. | @csv' <<<"$_default_transaction_field_headers"
}
main "$@"
