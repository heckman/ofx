#!/usr/bin/env bash
# ofx
# v0.3

usage(){ echo '
Usage: ofx <command> <ofx_file>

Commands:
   xml              print ofx data as xml (ofx v2)
   json             print ofx data as json
   csv              write transactions to a CSV file and rename OFX file
   trans            print transactions as CSV with headers
   trans-headers    print transactions as CSV with headers
   info             print bank, account, and range info
   range            print range of transaction dates
   bank             print name of bank
   bnk              print shorter name of bank
   baank            print longer name of bank
   account          print account number
   headers          print header row for CSV transactions
'
}

# Add an object for each the financial institutions you use.
# They are indexed by their INTU.BID value.
# INTU.BID is a Inutuit Bank ID; the values for North-American institutions can be found here:
# https://ofx-prod-filist.intuit.com/qm2400/data/fidir.txt
_fidir='
{
  "00002": {"short": "TD",   "medium": "TD Canada Trust", "long": "Toronto Dominion Canada Trust" },
  "00004": {"short": "FK",   "medium": "FK Canada Fake", "long": "Fakey Fake Financial Canada" },
  "00005": {"short": "CIBC", "medium": "CIBC",            "long": "Canadian Imperial Bank of Commerce" },
  "00015": {"short": "RBC",  "medium": "RBC RoyalBank",   "long": "Royal Bank of Canada" },
  "00024": {"short": "PC",   "medium": "PC Financial",    "long": "President'"'"'s Choice Financial" }
}
'
# NAMING CONVENTION for variables: leading _ indicates the string is a fragment of jq code.

# The variables that follow define the output format.

# The following fields are usually available from an OFX file:
# (fields marked with and * are generated by this script, derived from other fields)
#
# .BANKID     The Bank ID -- a nine-digit mysterious mapping of the financial institution.
# .ACCTID     Account number as it appears in the OFX file.
# .ACCTN    * Account number with all non numbers removed, derived from ACCTID.
# .ACCTSFX  * The last 4 digits of the account number, derived from ACCTID.
# .DTSTART    Start date-and-time of included transactions.
# .DSTART   * Start date of included transactions as YYYY-MM-DD, derived from DTSTART.
# .DTEND      End date-and-time of included transactions.
# .DEND     * End date of included transactions as YYYY-MM-DD, derived from DTSTART.
# .INTBID     Intuit's Bank ID, stored in the <INTU.BID> tag.
# .BNS      * Short-form name of Bank, derived from .INTBID and bank list defined below.
# .BNM      * Short-form name of Bank, derived from .INTBID and bank list defined below.
# .BNL      * Long-form name of Bank, derived from .INTBID and bank list defined below.
#
# Additionally, the following fields are usually available for transactions:
#
# .FITID       Transaction ID, unique to each account of a financial institution.
# .DTPOSTED    Date and Time Posted.
# .DPOSTED   * Date in YYYY-MM-DD format, derived from DTPOSTED.
# .TRNTYPE     Transaction type (CREDIT, DEBIT, ATM, etc.)
# .TRNAMT      Positive for credits, negative for debits, no dollar sign.
# .NAME        The first line of the description.
# .MEMO        The second line of the description.
# .DESC      * Description, derived from NAME and MEMO, which, when both are non-empty,
#              are joined by a delimiter defined below. (If either is empty then
#              they are joined without a delimiter.)
_description_deliminator='; '
# _description_deliminator='
# '

# these are used for the info command and when (re)naming files
_filename_format='.BNS + "-" + .ACCTSFX + " -- " + (.DSTART | gsub("-(?<d>\\d\\d)$"; "\(.d)")) + " - " + (.DEND | gsub("-(?<d>\\d\\d)$"; "\(.d)"))'

# this jq array is used to define the headers for the transaction fields:
_default_transaction_field_headers='[
	"ACCOUNT",
	"TRANSACTION ID",
	"DATE POSTED",
	"TYPE",
	"DESCRIPTION",
	"AMOUNT"
]'

# this jq array specifies fields to include for transactions:
_default_transaction_fields='[
	(.BNS + "-" + .ACCTSFX),
	.FITID,
	.DPOSTED,
	.TRNTYPE,
	.DESC,
	.TRNAMT
]'

# default options, in the future will be adjustable in command-line options
FORCE_OVERWRITE=true
RENAME_OFX=true
CSV_HEADERS=false


set -euo pipefail

# this is a global variable containing the path to the current OFX file
declare ofx

main(){
	local cmd="${1:-}"; shift
	[[ "$cmd" == "headers" ]] && { headers; return; }
	for ofx in "$@"; do
		[[ -f "$ofx" ]] || { usage >&2; exit 69; }
		[[ -r "$ofx" ]] || { usage >&2; exit 69; }
		case "$cmd" in
		xml) xml;;
		json) xml | xq -j | cat;;
		csv) csv;;
		trans|transactions) transactions;;
		trans-headers) headers; transactions;;
		range) info '.DSTART + " to " + .DEND';;
		bank) info '.BNM';;
		bnk) info '.BNS';;
		baank) info '.BNL';;
		info) info '.BNL + ", account " + .ACCTID + ", from " + .DSTART + " to " + .DEND + "."' ;;
		account) info '.ACCTID';;
		headers) headers;;
		*) usage >&2; exit 69;;
		esac
	done
}


# writes a csv file, optionally also renames the original ofx file
#
# shellcheck disable=SC2120  # don't be alarmed if the default fields are always used!
csv(){
	parse "${1:-$_filename_format}" "${2:-$_default_transaction_fields} | @csv" | {
		read -r info_string
		filename="${info_string}.csv"
		[[ -e "$filename" ]] && ! $FORCE_OVERWRITE && die "Error: $filename already exists."
		{
			$CSV_HEADERS && headers
			cat -
		} > "$filename"
		$RENAME_OFX && mv "$ofx" "${info_string}.ofx"
	}
}


xml(){
	ofx2xml "$ofx"
}
json(){
	xml | xq -j | cat  # `cat` prevents output from being interactive (which causes errors for ofx2xml)
}
info(){ parse "$1" | head -n 1; }

# shellcheck disable=SC2120  # don't be alarmed if the default fields are always used!
transactions(){ parse '' "${2:-$_default_transaction_fields} | @csv" | tail -n +2; }


die(){
	echo "$@" >&2
	exit 1
}
headers(){
	jq -r '. | @csv' <<<"$_default_transaction_field_headers"
}
# derives json then outputs , on the first line, summary info,
# then, on the subsequent lines, transaction info

parse(){
	local _info_format="${1:-\"\"}"
	local _txn_format="${2:-\"\"}"
	# shellcheck disable=SC2016 # the dollarsigns are jq variables
	json | jq -r --argjson fidir "$_fidir" '
	.OFX
	| ({ INTBID: (.SIGNONMSGSRSV1.SONRS.FI.FID // "") }) as $props
	| ( $props + '"$_derived_bank_names"' )	as $props
	| if has("BANKMSGSRSV1") then .BANKMSGSRSV1.STMTTRNRS
		| if type == "array" then .[0] else . end
		| .STMTRS
	elif has("CREDITCARDMSGSRSV1") then .CREDITCARDMSGSRSV1.CCSTMTTRNRS
		| if type == "array" then .[0] else . end
		| .CCSTMTRS
	else
		error("Unknown OFX type")
	end
	| ( $props + '"$_file_info"' ) as $props
	| ( $props + '"$_derived_file_info"' ) as $props
	| .BANKTRANLIST
	| (
		( . + $props | '"$_info_format"' ),
		(
			.STMTTRN | if type == "array" then . else [.] end
			| .[]
			| . + '"$_derived_transaction_fields"'
			| . + $props
			| '"$_txn_format"'
		)
	)
	'
}

# shellcheck disable=SC2016 # the dollarsigns are jq variables
_derived_bank_names='{
	BNS: $fidir[$props.INTBID].short,
	BNM: $fidir[$props.INTBID].medium,
	BNL: $fidir[$props.INTBID].long
}'
_file_info='{
	BANKID: ((.BANKACCTFROM.BANKID // "")+(.CCACCTFROM.BANKID // "")),
	ACCTID: ((.BANKACCTFROM.ACCTID // "")+(.CCACCTFROM.ACCTID // "")),
	DTSTART: (.BANKTRANLIST.DTSTART // ""),
	DTEND: (.BANKTRANLIST.DTEND // "")
}'
# shellcheck disable=SC2016 # the dollarsigns are jq variables
_derived_file_info='{
	ACCTN: ($props.ACCTID | gsub("[^A-Za-z0-9]"; "")),
	ACCTSFX: ($props.ACCTID | gsub("[^A-Za-z0-9]"; "") | .[-4:]),
	DSTART: ($props.DTSTART[0:4]+"-"+$props.DTSTART[4:6]+"-"+$props.DTSTART[6:8]),
	DEND: ($props.DTEND[0:4]+"-"+$props.DTEND[4:6]+"-"+$props.DTEND[6:8])
}'
_derived_transaction_fields='{
	DPOSTED: (
		.DTPOSTED[0:4]+"-"+.DTPOSTED[4:6]+"-"+.DTPOSTED[6:8]
	),
	DESC: (
		if ((.NAME//"") != "" and (.MEMO//"") != "")
		then (.NAME//"") + "'"$_description_deliminator"'" + (.MEMO//"")
		else (.NAME//"") + (.MEMO//"")
		end
	),
	# in transaction amounts, add zeros for cents if missing
	TRNAMT: (
		.TRNAMT
		| gsub("^(?<a>-?\\d+)$";"\(.a).00")
		| gsub("^(?<a>-?\\d+\\.\\d)$";"\(.a)0")
	)
}'



main "$@"
